/**
 * src/flows/lead-capture.flow.ts
 *
 * ImplementaciÃ³n del flujo de captura de leads en BuilderBot
 * basado en la plantilla "Flujo BÃ¡sico Lead".
 *
 * Este flujo demuestra la transformaciÃ³n de una plantilla visual
 * a cÃ³digo de BuilderBot con Ã©nfasis en la gestiÃ³n correcta de estado
 * y variables para permitir integraciÃ³n entre mÃºltiples plantillas.
 *
 * @version 1.0.1
 * @created 2025-05-10
 * @updated 2025-10-05
 */

import { addKeyword, addAction, createFlow } from "@builderbot/bot";
import { logAuditAction, AuditActionType } from "../services/auditService";
import { saveConversationState, loadConversationState } from "../services/stateManager";
import logger from "../utils/logger";

/**
 * Flujo de captura y calificaciÃ³n de leads implementado con BuilderBot
 *
 * Este flujo mantiene el estado persistente para permitir:
 * - IntegraciÃ³n con otras plantillas
 * - RecuperaciÃ³n de conversaciones interrumpidas
 * - Uso de variables en mÃºltiples flujos
 * - SincronizaciÃ³n del estado con Supabase
 */
const leadCaptureFlowDefinition = addKeyword(['INICIO', 'HOLA', 'LEAD'])
  /**
   * Mensaje de bienvenida (messageNode-welcome)
   */
  .addAnswer(
    'ðŸ‘‹ Hola, soy el asistente virtual de AgentProp. Â¿En quÃ© puedo ayudarte hoy?',
    null,
    async (ctx, { flowDynamic, state }) => {
      try {
        // Intentamos cargar estado existente primero
        const sessionId = ctx.message?.sessionId || `session-${ctx.from}-${Date.now()}`;
        const tenantId = ctx?.message?.tenantId || 'default';
        const userId = ctx.from || 'unknown';
        
        // Intentamos recuperar el estado guardado en la base de datos
        const savedState = await loadConversationState(tenantId, userId, sessionId);
        
        // Si hay estado guardado, lo cargamos en el estado de BuilderBot
        if (savedState && Object.keys(savedState).length > 0) {
          logger.info(`Restaurando estado existente para sesiÃ³n ${sessionId}`);
          await state.update(savedState);
        } else {
          logger.info(`Iniciando nueva conversaciÃ³n con sesiÃ³n ${sessionId}`);
          // Inicializamos el estado con datos bÃ¡sicos de la sesiÃ³n
          await state.update({
            flow_id: 'lead-capture',
            session_id: sessionId,
            tenant_id: tenantId,
            user_id: userId,
            started_at: new Date().toISOString(),
            last_updated_at: new Date().toISOString()
          });
        }

        // Registramos el inicio de la conversaciÃ³n
        await logAuditAction({
          action: AuditActionType.CHAT_START,
          userId: userId,
          tenantId: tenantId,
          resourceId: 'lead-capture',
          resourceType: 'flow',
          resourceName: 'Flujo BÃ¡sico Lead',
          details: {
            channel: ctx?.message?.channel || 'unknown',
            platformId: userId,
            sessionId: sessionId
          }
        }).catch(err => logger.error('Error al registrar inicio de chat:', err));

        // Enviamos la siguiente pregunta (solicitamos nombre)
        await flowDynamic('Para brindarte una mejor atenciÃ³n, Â¿podrÃ­as decirme tu nombre?');
      } catch (error) {
        logger.error('Error al iniciar flujo lead-capture:', error);
        await flowDynamic('Para brindarte una mejor atenciÃ³n, Â¿podrÃ­as decirme tu nombre?');
      }
    }
  )

  /**
   * Captura de nombre (inputNode-nombre)
   */
  .addAnswer(
    null, // No enviamos texto adicional aquÃ­
    { capture: true }, // Capturamos la respuesta
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const nombre = ctx.body;
        
        // Actualizamos tanto el estado local como la variable especÃ­fica
        await state.update({ 
          nombre_usuario: nombre,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-nombre'
        });

        logger.info(`Nombre capturado: ${nombre}`);
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Enviamos la siguiente pregunta (solicitamos email)
        await flowDynamic(`Gracias ${nombre}. Â¿CuÃ¡l es tu correo electrÃ³nico?`);
      } catch (error) {
        logger.error('Error al capturar nombre:', error);
        // En caso de error, continuamos con la siguiente pregunta
        await flowDynamic('Â¿CuÃ¡l es tu correo electrÃ³nico?');
      }
    }
  )

  /**
   * Captura de email (inputNode-email)
   */
  .addAnswer(
    null,
    { capture: true },
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const email = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          email_usuario: email,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-email'
        });

        logger.info(`Email capturado: ${email}`);
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Enviamos la siguiente pregunta (solicitamos telÃ©fono)
        await flowDynamic('Â¿Y tu nÃºmero de telÃ©fono?');
      } catch (error) {
        logger.error('Error al capturar email:', error);
        await flowDynamic('Â¿Y tu nÃºmero de telÃ©fono?');
      }
    }
  )

  /**
   * Captura de telÃ©fono (inputNode-phone)
   */
  .addAnswer(
    null,
    { capture: true },
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const telefono = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          telefono_usuario: telefono,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-phone'
        });

        logger.info(`TelÃ©fono capturado: ${telefono}`);
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Enviamos el mensaje de introducciÃ³n a las preguntas de calificaciÃ³n
        await flowDynamic(`Gracias por tus datos, ${currentState.nombre_usuario}. Para poder ayudarte mejor, necesito hacerte algunas preguntas sobre lo que estÃ¡s buscando.`);
        await flowDynamic('Â¿EstÃ¡s buscando una propiedad para comprar o rentar?');
      } catch (error) {
        logger.error('Error al capturar telÃ©fono:', error);
        await flowDynamic('Para poder ayudarte mejor, necesito hacerte algunas preguntas sobre lo que estÃ¡s buscando. Â¿EstÃ¡s buscando una propiedad para comprar o rentar?');
      }
    }
  )

  /**
   * Captura de preferencia compra/renta (inputNode-q1)
   */
  .addAnswer(
    null,
    { capture: true },
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const compraRenta = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          compra_renta: compraRenta,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-q1'
        });
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Enviamos la siguiente pregunta de calificaciÃ³n
        await flowDynamic('Â¿QuÃ© tipo de propiedad estÃ¡s buscando? (casa, departamento, oficina, etc.)');
      } catch (error) {
        logger.error('Error al capturar preferencia:', error);
        await flowDynamic('Â¿QuÃ© tipo de propiedad estÃ¡s buscando? (casa, departamento, oficina, etc.)');
      }
    }
  )

  /**
   * Captura de tipo de propiedad (inputNode-q2)
   */
  .addAnswer(
    null,
    { capture: true },
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const tipoPropiedad = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          tipo_propiedad: tipoPropiedad,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-q2'
        });
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Enviamos la siguiente pregunta de calificaciÃ³n
        await flowDynamic('Â¿CuÃ¡l es tu presupuesto aproximado?');
      } catch (error) {
        logger.error('Error al capturar tipo de propiedad:', error);
        await flowDynamic('Â¿CuÃ¡l es tu presupuesto aproximado?');
      }
    }
  )

  /**
   * Captura de presupuesto (inputNode-q3)
   */
  .addAnswer(
    null,
    { capture: true },
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const presupuesto = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          presupuesto: presupuesto,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-q3',
          
          // TambiÃ©n marcamos que el lead estÃ¡ parcialmente calificado
          lead_status: 'qualified',
          lead_qualification_date: new Date().toISOString()
        });
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Enviamos el mensaje de lead calificado
        await flowDynamic(`Â¡Excelente ${currentState.nombre_usuario}! Basado en tus respuestas, tenemos varias propiedades que podrÃ­an interesarte. Me gustarÃ­a que uno de nuestros asesores te contacte para mostrarte opciones personalizadas.`);
        
        // Preguntamos si quiere agendar una cita
        await flowDynamic('Â¿Te gustarÃ­a agendar una cita con uno de nuestros asesores? (sÃ­/no)');
      } catch (error) {
        logger.error('Error al capturar presupuesto:', error);
        await flowDynamic('Â¿Te gustarÃ­a agendar una cita con uno de nuestros asesores? (sÃ­/no)');
      }
    }
  )

  /**
   * Captura confirmaciÃ³n de cita y bifurcaciÃ³n condicional (inputNode-agendar + condicion-cita)
   */
  .addAnswer(
    null,
    { capture: true },
    async (ctx, { flowDynamic, state }) => {
      try {
        // Obtenemos el estado actual
        const currentState = await state.get();
        const confirmaCita = ctx.body.toLowerCase();
        
        // Actualizamos el estado
        await state.update({ 
          confirma_cita: confirmaCita,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'condicion-cita'
        });
        
        // Determinamos la ruta a seguir (bifurcaciÃ³n condicional)
        const quiereCita = confirmaCita.includes('sÃ­') || 
                          confirmaCita.includes('si') || 
                          confirmaCita === 'si' || 
                          confirmaCita === 'sÃ­';
        
        // Actualizamos el estado con la decisiÃ³n
        await state.update({
          quiere_agendar_cita: quiereCita
        });
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));

        // Implementamos el nodo condicional
        if (quiereCita) {
          // Ruta SI - Agendamos fecha
          await flowDynamic('Â¿Para quÃ© fecha te gustarÃ­a agendar la cita? (formato: DD/MM/YYYY)');
        } else {
          // Ruta NO - Mensaje sin cita
          await flowDynamic('No hay problema. Uno de nuestros asesores se pondrÃ¡ en contacto contigo pronto para proporcionarte informaciÃ³n sobre propiedades que podrÃ­an interesarte.');
          
          // Enviamos mensaje de despedida
          await flowDynamic('Gracias por usar nuestro asistente virtual. Si tienes mÃ¡s preguntas o necesitas ayuda adicional, no dudes en contactarnos. Â¡Que tengas un excelente dÃ­a!');
          
          // Actualizamos el estado como completado
          await state.update({
            conversation_status: 'completed',
            end_time: new Date().toISOString(),
            completed_flow: true
          });
          
          // Guardamos el estado final
          await saveConversationState(
            tenantId, 
            userId, 
            sessionId, 
            await state.get()
          ).catch(err => logger.warn('Error al guardar estado final:', err));
          
          // Registramos la finalizaciÃ³n del flujo
          await logAuditAction({
            action: AuditActionType.CHAT_COMPLETED,
            userId: userId,
            tenantId: tenantId,
            resourceId: 'lead-capture',
            resourceType: 'flow',
            resourceName: 'Flujo BÃ¡sico Lead',
            details: {
              leadCaptured: true,
              appointmentScheduled: false,
              leadData: {
                nombre: currentState.nombre_usuario,
                email: currentState.email_usuario,
                telefono: currentState.telefono_usuario,
                tipoPropiedad: currentState.tipo_propiedad,
                presupuesto: currentState.presupuesto,
                compraRenta: currentState.compra_renta
              }
            }
          }).catch(err => logger.error('Error al registrar finalizaciÃ³n de chat:', err));
        }
      } catch (error) {
        logger.error('Error al procesar confirmaciÃ³n de cita:', error);
        await flowDynamic('Lo siento, hubo un problema al procesar tu respuesta. Por favor, intenta nuevamente mÃ¡s tarde o contacta directamente con nuestro equipo de atenciÃ³n al cliente.');
      }
    }
  )

  /**
   * Captura de fecha (inputNode-fecha) - Solo para la ruta SI
   */
  .addAction(async (ctx, { flowDynamic, state }) => {
    try {
      const currentState = await state.get();
      
      // Solo procesamos si estamos en la ruta de confirmar cita
      if (currentState.quiere_agendar_cita === true) {
        // Capturamos la fecha
        const fechaCita = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          fecha_cita: fechaCita,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'inputNode-fecha'
        });
        
        // Guardamos el estado en la base de datos para persistencia
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado de conversaciÃ³n:', err));
        
        // Preguntamos por la hora
        await flowDynamic('Â¿A quÃ© hora prefieres? Tenemos disponibilidad entre 9 AM y 6 PM');
      }
    } catch (error) {
      logger.error('Error al capturar fecha de cita:', error);
    }
  })

  /**
   * Captura de hora (inputNode-hora) - Solo para la ruta SI
   */
  .addAction(async (ctx, { flowDynamic, state }) => {
    try {
      const currentState = await state.get();
      
      // Solo procesamos si estamos en la ruta de confirmar cita y ya tenemos fecha
      if (currentState.quiere_agendar_cita === true && currentState.fecha_cita) {
        // Capturamos la hora
        const horaCita = ctx.body;
        
        // Actualizamos el estado
        await state.update({ 
          hora_cita: horaCita,
          last_updated_at: new Date().toISOString(),
          last_node_id: 'messageNode-cita-confirmada',
          
          // Actualizamos el estado de la conversaciÃ³n
          conversation_status: 'completed',
          end_time: new Date().toISOString(),
          completed_flow: true,
          
          // Marcamos que se agendÃ³ una cita
          appointment_scheduled: true,
          appointment_date: currentState.fecha_cita,
          appointment_time: horaCita
        });
        
        // Confirmamos la cita
        await flowDynamic(`Â¡Perfecto! Tu cita ha sido agendada para el ${currentState.fecha_cita} a las ${horaCita}. Te enviaremos un correo con los detalles y uno de nuestros asesores se comunicarÃ¡ contigo pronto.`);
        
        // Enviamos mensaje de despedida
        await flowDynamic('Gracias por usar nuestro asistente virtual. Si tienes mÃ¡s preguntas o necesitas ayuda adicional, no dudes en contactarnos. Â¡Que tengas un excelente dÃ­a!');
        
        // Guardamos el estado final en la base de datos
        const sessionId = currentState.session_id || ctx.message?.sessionId;
        const tenantId = currentState.tenant_id || ctx?.message?.tenantId;
        const userId = currentState.user_id || ctx.from;
        
        await saveConversationState(
          tenantId, 
          userId, 
          sessionId, 
          await state.get()
        ).catch(err => logger.warn('Error al guardar estado final de conversaciÃ³n:', err));
        
        // Registramos la finalizaciÃ³n del flujo con cita
        await logAuditAction({
          action: AuditActionType.CHAT_COMPLETED,
          userId: userId,
          tenantId: tenantId,
          resourceId: 'lead-capture',
          resourceType: 'flow',
          resourceName: 'Flujo BÃ¡sico Lead',
          details: {
            leadCaptured: true,
            appointmentScheduled: true,
            appointmentDate: currentState.fecha_cita,
            appointmentTime: horaCita,
            leadData: {
              nombre: currentState.nombre_usuario,
              email: currentState.email_usuario,
              telefono: currentState.telefono_usuario,
              tipoPropiedad: currentState.tipo_propiedad,
              presupuesto: currentState.presupuesto,
              compraRenta: currentState.compra_renta
            }
          }
        }).catch(err => logger.error('Error al registrar finalizaciÃ³n de chat con cita:', err));
      }
    } catch (error) {
      logger.error('Error al capturar hora de cita:', error);
    }
  });

// Creamos un adaptador de flujo completo utilizando el flujo definido arriba
// Esto es crucial para que podamos acceder a handleMsg y otras funciones del flow adapter
const leadCaptureFlow = createFlow([leadCaptureFlowDefinition]);

// Exportamos el adaptador completo que contiene el mÃ©todo handleMsg
export default leadCaptureFlow;